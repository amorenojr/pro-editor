{
    "Summary Block": {
        "prefix": "summary",
        "body": [
            "/* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━",
            "/* #region ${1:Name} Summary",
            "/*     Description  : ${2:Description}",
            "/*     Usage        : ${3:Usage}",
            "/*     Authors      : ${4:Full Name, Email}",
            "/*     Contributors : ${5:Full Name, Email}",
            "/*     Version      : ${6:0.0.0.0}",
            "/*     CreatedOn    : ${7:yyyy-MM-dd HH:mmK}",
            "/*     ModifiedOn   : ${8:yyyy-MM-dd HH:mmK}",
            "/* #endregion ${1:Name} Summary",
            "/* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        ],
        "description": "Summary Block"
    },
    "Named Region": {
        "prefix": "#region",
        "body": [
            "/* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━",
            "/* #region ${1:Name}",
            "",
            "${2:Code}",
            "",
            "/* #endregion ${1:Name}",
            "/* ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        ],
        "description": "Named Region"
    },
    "if Statement": {
        "prefix": "if",
        "body": [
            "if ${1:condition}",
            "\t${2:x}",
            "endif"
        ],
        "description": "The `if` test or the switching function, where the `condition` is evaluated and `x` is the returned value. If the condition results in a non-zero value, the result of the function is `x`; if not, no result."
    },
    "if else Statement": {
        "prefix": "if else",
        "body": [
            "if ${1:condition}",
            "\t${2:x}",
            "else",
            "\t${3:y}",
            "endif"
        ],
        "description": "The `if` test or the switching function, where the `condition` is evaluated, and `x` and `y` are the returned values. If the condition results in a non-zero value, the result of the function is `x`; if not, the result of the function is `y`."
    },
    "else Statement": {
        "prefix": "else",
        "body": [
            "else",
            "\t${1:y}",
        ],
        "description": "The `else` test or the switching function that can be nested in the `if ` statement."
    },
    "var": {
        "prefix": "var",
        "body": [
            "${1:param_name} = ${2:param_value}"
        ],
        "description": "General variable"
    },
    "string": {
        "prefix": "string",
        "body": [
            "${1:param_name} = \"${2:param_value}\""
        ],
        "description": "String variable"
    },
    "real": {
        "prefix": "real",
        "body": [
            "${1:param_name} = ${2:param_value}"
        ],
        "description": "Real number variable"
    },
    "integer": {
        "prefix": "int",
        "body": [
            "${1:param_name} = ${2:param_value}"
        ],
        "description": "Integer number variable"
    },
    "boolean": {
        "prefix": "bool",
        "body": [
            "${1:param_name} = ${2:param_value}"
        ],
        "description": "Boolean variable"
    },
    "comment": {
        "prefix": "comment",
        "body": [
            "/* ${1:comment}"
        ],
        "description": "Comment line"
    },
    "solve": {
        "prefix": "solve",
        "body": [
            "solve",
            "",
            "for ${1:var0 var1 ... varN}"
        ],
        "description": "Comment line"
    },
    "abs": { "prefix": "abs", "body": [ "abs(${1:x})" ], "description": "Returns the absolute value of x. If x≥0, the result of the function is x; if x<0, the result of the function is -x." },
    "acos": { "prefix": "acos", "body": [ "acos(${1:x})" ], "description": "Arc cosine function, where the value of x lies between -1.0 and 1.0. Result is the angular value in degrees." },
    "asin": { "prefix": "asin", "body": [ "asin(${1:x})" ], "description": "Arc sine function, where the value of x is between -1.0 and 1.0. Result is the angular value in degrees." },
    "atan": { "prefix": "atan", "body": [ "atan(${1:x})" ], "description": "Arc tangent function, where x is a numeric value. Result is the angular value in degrees." },
    "atan2": { "prefix": "atan2", "body": [ "atan2(${1:x},${2:y})" ], "description": "Arc tangent function of y/x, where x and y are any numeric values. Result is the angular value in degrees." },
    "bound": { "prefix": "bound", "body": [ "bound(${1:x},${2:lo},${3:hi})" ], "description": "Limits x between the 'lo' and the 'hi' values. If x < lo; the result of the function is lo; if x > hi, the result is hi; for all other values of x, the result of the function is x. The 'lo' value must be smaller than the 'hi' value." },
    "cable_len": { "prefix": "cable_len", "body": [ "cable_len(\"${1:cable_name}\",${2:location_id1},${3:location_id2})" ], "description": "Calculates the current length of a cable or bundle where cable_name is the name of the cable or bundle that you want to measure in the current harness and location_id is the internal feature ID of the location through which cable_name is routed, where location_id1 and location_id2 denote the locations between which the length is to be calculated." },
    "cable_think": { "prefix": "cable_think", "body": [ "cable_think(\"${1:cable_name}\",${2:location_id})" ], "description": "Calculates the maximum diameter of a cable, wire, or bundle at a specific location where cable_name is the name of the cable, wire, or bundle that you want to measure in the current harness and location_id is the internal feature ID of the location through which cable_name is routed." },
    "cbl_logical_file": { "prefix": "cbl_logical_file", "body": [ "cbl_logical_file(\"${1:filename}\")" ], "description": "Create a relation to the logical data file name that you import in an assembly. Note that this relation will return a value only if defined at an assembly level with logical data. The relation returns the name of the file as value. This relation can be assigned to a parameter. This parameter, when designated, can be used in Windchill to identify logical file name used in the cabling assembly without retrieving that assembly. The parameter helps you locate the referenced logical data file when you want to update it." },
    "ceil": { "prefix": "ceil", "body": [ "ceil(${1:x},[${n}])" ], "description": "Rounds (x - 0.000 000 001) toward positive infinity. Optionally, specify n number of decimal places." },
    "comparegraphs": { "prefix": "comparegraphs", "body": [ "comparegraphs(\"${1:name_1}\",\"${2:name_2}\",\"${3:type}\",${4:left_bound_1},${5:right_bound_1},${5:left_bound_2},${6:right_bound_2})" ], "description": "Matching two graphs involves two basic steps:\n1.Create a Relation Analysis Feature that compares two graphs. Use the Analysis feature to compute the difference between the graphs.\n2.Run an optimization study to minimize the difference.\nwhere:\n•relation_name—is the name for the relation.\n•name_1—is the name for the first graph or analysis feature.\n•name_2—is the name for the second graph or analysis feature.\n•left_bound_1 and right_bound_1—are the left and right boundaries of the first graph.\n•left_bound_2 and right_bound_2—are the left and right boundaries of the second graph.\n•type—is the method for computing the difference between the graphs. Choose from the following types: lone (default), ltwo, linf, or area. The table explains the different types of measurement." },
    "cos": { "prefix": "cos", "body": [ "cos(${1:x})" ], "description": "Cosine trigonometric function, where x is an angular value in degrees." },
    "cosh": { "prefix": "cosh", "body": [ "cosh(${1:x})" ], "description": "Hyperbolic cosine function, where the value of x lies between -85.0 and 85.0" },
    "count_rows": { "prefix": "count_rows", "body": [ "count_rows(${1:Param})" ], "description": "Returns the number of rows in the parameter. Where: Param—name of a parameter." },
    "dbl_in_tol": { "prefix": "dbl_in_tol", "body": [ "dbl_in_tol(${1:arg1},${2:arg2},${3:arg3})" ], "description": "Checks whether a real number arg 1 matches another real number arg 2 within a specified tolerance arg 3. It returns TRUE, if the value of arg1 is between (arg 2 - arg 3) and (arg 2 + arg 3).\nThe function returns TRUE, if, the following condition is met:arg1 <= arg2+arg3 && arg1 >= arg2-arg3.\nFor example, to check if a given angle equals 45 degree within a tolerance of 3 degree. If the given angle (arg1) is 47, then it is within the range of arg2-arg3 (45-3) and arg2+arg3(45+3)." },
    "dead": { "prefix": "dead", "body": [ "dead(${1:x},${2:lo},${3:hi})" ], "description": "Defines a range of values for x, for which the result of the function is 0. 'lo' and 'hi' define the range of values. If x < lo, the result of the function is x-lo; if x > hi, the result of the function is x-hi, if x is between “lo” and “hi”, the result of the function is 0." },
    "eang": { "prefix": "eang", "body": [ "eang(${1:e_ID1},${2:e_ID2})" ], "description": "Angle in radians between two entities, e_ID1 and e_ID2, of a case study where e_ID1 and e_ID2 are integers that identify the Case Study entities." },
    "ecoordx": { "prefix": "ecoordx", "body": [ "ecoordx(${1:e_ID1})" ], "description": "Returns the x coordinate of the e_ID1 entity of a case study where e_ID1 is an integer that identifies the Case Study entity." },
    "ecoordy": { "prefix": "ecoordy", "body": [ "ecoordy(${1:e_ID1})" ], "description": "Returns the y coordinate of the e_ID1 entity of a case study where e_ID1 is an integer that identifies the Case Study entity." },
    "edist": { "prefix": "edist", "body": [ "edist(${1:e_ID1},${2:e_ID2})" ], "description": "Distance between two entities, e_ID1 and e_ID2 where e_ID1 and e_ID2 are integers that identify the Case Study entities." },
    "elen": { "prefix": "elen", "body": [ "elen(${1:e_ID1})" ], "description": "Length of the e_ID1 entity of a case study where e_ID1 is an integer that identifies the Case Study entity." },
    "evalgraph": { "prefix": "evalgraph", "body": [ "evalgraph(\"${1:graph_name}\",${2:x})" ], "description": "Graph evaluation function enables you to use graph features to drive dimensions through relations where graph_name is the name of the graph and x is the value along the x-axis of the graph for which the y value is returned. For sweep features, you can specify the trajectory parameter trajpar as the second argument of this function." },
    "exists": { "prefix": "exists", "body": [ "exists('${1:param}')" ], "description": "Evaluates whether an item, such as a parameter or dimension, exists. This can apply to the model for which the relation is being evaluated, or to any model, component, or submodel structure." },
    "exp": { "prefix": "exp", "body": [ "exp(${1:x})" ], "description": "e to an exponential degree x." },
    "extract": { "prefix": "extract", "body": [ "extract(${1:string},${2:position},${3:length})" ], "description": "Extracts pieces of string beginning at position for length number of characters." },
    "floor": { "prefix": "floor", "body": [ "floor(${1:x},[${n}])" ], "description": "Rounds (x + 0.000 000 001) toward negative infinity. Optionally, specify n number of decimal places." },
    "has_value": { "prefix": "has_value", "body": [ "has_value(${1:Param},${2:Value},[${3:Column}])" ], "description": "Returns True if the value exists in the specified column. Otherwise returns False. Where: Param—name of a parameter, Value—value to check for column (optional)—column number." },
    "itos": { "prefix": "itos", "body": [ "itos(${1:int})" ], "description": "Converts integers to strings. Here, int can be a number or an expression. Non-integers are rounded off." },
    "ln": { "prefix": "ln", "body": [ "ln(${1:x})" ], "description": "Natural logarithm of x (logarithm to the base e)" },
    "log": { "prefix": "log", "body": [ "log(${1:x})" ], "description": "Common logarithm of x (logarithm to the base 10)" },
    "lookup_inst": { "prefix": "lookup_inst", "body": [ "lookup_inst(\"${1:generic_name}\",${2:match_mode},\"${3:param_name_1}\",${4:match_value_1},\"${5:param_name_2}\",${5:match_value_2},…)" ], "description": "You can automatically replace family table-driven components according to design criteria by using the lookup_inst function. With this function, you can search a component family table to find an instance that fits the values of the search parameters. If the lookup function does not find a match, it returns the name of the generic. where\n•generic name—Name of the generic model with a prt or asm extension\n•match_mode—One of the following values:\n◦-1 (find closest instance with param values less than or equal to supplied values)\n◦0 (find instance with param values that match supplied values exactly)\n◦1 (find closest instance with param values greater than or equal to supplied values)\n•param_name_1—Family table parameter name\n•match_value_1—Value to match against" },
    "massprop_param": { "prefix": "massprop_param", "body": [ "massprop_param(\"${1:mass property name}\")" ], "description": "Obtains the value of the mass property parameter where \"mass property name\" can be one of the following: AREA, VOLUME, DENSITY, XCG, YCG, ZCG, IXX, IYY, IZZ, IXY, IXZ, IYZ, INRT1, INRT2, and INRT3." },
    "match_value": { "prefix": "match_value", "body": [ "match_value(${1:Param},${2:Value},[${3:Column}])" ], "description": "Returns the topmost row where the value is found in the column. If param is not found it returns 0. Otherwise returns error. Where: Param—name of a parameter, Value—value to check for, column (optional)—column number." },
    "material_param": { "prefix": "material_param", "body": [ "material_param(\"${1:PARAM_NAME}\",\"${2:MATERIAL_NAME}\")" ], "description": "Returns the value of “PARAM_NAME” from the currently assigned material in the current model or the value of “PARAM_NAME” from “MATERIAL_NAME” of the current model." },
    "max": { "prefix": "max", "body": [ "max(${1:x},${2:y})" ], "description": "Returns either x or y, whichever is the maximum value. If x > y, the result of the function is x; if x<=y, the result of the function is y." },
    "min": { "prefix": "min", "body": [ "min(${1:x},${2:y})" ], "description": "Returns either x or y, whichever is the minimum value. If x < y, the result of the function is x; if x >=y, the result of the function is y." },
    "mod": { "prefix": "mod", "body": [ "mod(${1:x},${2:y})" ], "description": "Remainder function (Modulus), that is x-int(x/y)*y, where int() is “integer part of”. The sign of the result is always the same as the sign of x." },
    "mp_assigned_mass": { "prefix": "mp_assigned_mass", "body": [ "mp_assigned_mass(\"${1:string}\")" ], "description": "Obtains mass of a model. This function is defined only when the mass properties of a model are assigned through a file. Where string is an expression that is evaluated to string value." },
    "mp_cg_x": { "prefix": "mp_cg_x", "body": [ "mp_cg_x(\"${1:string}\")" ], "description": "Obtains the X-coordinate of the center of gravity of the model where string is an expression that is evaluated to string value." },
    "mp_cg_y": { "prefix": "mp_cg_y", "body": [ "mp_cg_y(\"${1:string}\")" ], "description": "Obtains the Y-coordinate of the center of gravity of the model where string is an expression that is evaluated to string value." },
    "mp_cg_z": { "prefix": "mp_cg_z", "body": [ "mp_cg_z(\"${1:string}\")" ], "description": "Obtains the Z-coordinate of the center of gravity of the model where string is an expression that is evaluated to string value." },
    "mp_mass": { "prefix": "mp_mass", "body": [ "mp_mass(\"${1:string}\")" ], "description": "Returns the mass of a model part or assembly where string is an expression that is evaluated to string value." },
    "mp_surf_area": { "prefix": "mp_surf_area", "body": [ "mp_surf_area(\"${1:string}\")" ], "description": "Returns the area of a model part or assembly where string is an expression that is evaluated to string value." },
    "mp_volume": { "prefix": "mp_volume", "body": [ "mp_volume(\"${1:string}\")" ], "description": "Returns the volume of a model part or assembly where string is an expression that is evaluated to string value." },
    "near": { "prefix": "near", "body": [ "near(${1:x},${2:y},${3:delta})" ], "description": "Tests whether two values are close, where x and y are the two values and delta defines their permissible difference. If x lies within delta of y, the result of the function is 1.0 (true). If abs(x–y) <= delta, the result of the function is 1.0; if abs(x-y) > delta, the result of the function is 0.0." },
    "pow": { "prefix": "pow", "body": [ "pow(${1:num1},${2:num2})" ], "description": "Obtains the value of num1 to the power num2." },
    "search": { "prefix": "search", "body": [ "search(${1:string},${2:substring})" ], "description": "Searches for substrings. The resulting value is the position of the substring in the string (0 if not found). You can specify substrings with single or double quotes." },
    "sign": { "prefix": "sign", "body": [ "sign(${1:x},${2:y})" ], "description": "Sign transfer of y to x. If y<0, the result is -abs(x); if y>=0, the result is abs(x)." },
    "sin": { "prefix": "sin", "body": [ "sin(${1:x})" ], "description": "Sine trigonometric function, where x is an angular value in degrees." },
    "sinh": { "prefix": "sinh", "body": [ "sinh(${1:x})" ], "description": "Hyperbolic sine function, where the value of x lies between -85.0 and 85.0" },
    "sqrt": { "prefix": "sqrt", "body": [ "sqrt(${1:x})" ], "description": "Square root of x" },
    "string_ends": { "prefix": "string_ends", "body": [ "string_ends(${1:string1},${2:string2})" ], "description": "TRUE, if the value of string1 ends with the value of string2." },
    "string_length": { "prefix": "string_length", "body": [ "string_length(${1:string})" ], "description": "Returns the number of characters in a parameter value or string." },
    "string_match": { "prefix": "string_match", "body": [ "string_match(${1:string1},${2:string2})" ], "description": "TRUE, if the value of string1 matches the value of string2." },
    "string_starts": { "prefix": "string_starts", "body": [ "string_starts(${1:string1},${2:string2})" ], "description": "TRUE, if the value of string1 starts with the value of string2." },
    "tan": { "prefix": "tan", "body": [ "tan(${1:x})" ], "description": "Tangent trigonometric function, where x is an angular value in degrees." },
    "tanh": { "prefix": "tanh", "body": [ "tanh(${1:x})" ], "description": "Hyperbolic tangent function, where the value of x lies between -85.0 and 85.0" },
    "trajpar": { "prefix": "trajpar", "body": [ "trajpar()" ], "description": " represents a trajectory path in Creo. Its value ranges from 0 to 1, with 0 representing the beginning of the trajectory, and 1 representing the trajectory end. It is used as the independent variable in a relation. You type a relation using trajpar after you draw the section sketch, while the Sketch tab is still open." },
    "trajpar_of_pnt": { "prefix": "trajpar_of_pnt", "body": [ "trajpar_of_pnt(\"${1:trajname}\",'\"${2:pointname}\")" ], "description": "The trajectory parameter of a composite curve, trajpar_of_pnt, can be used in relations. The following function returns a value between 0.0 and 1.0 where trajname the name of a composite curve and pointname the name of a datum point." },
    "value": { "prefix": "value", "body": [ "value(${1:Param},${2:Value},[${3:column}])" ], "description": "Returns the value in the specified cell when used in the right side of the relation. Sets the value for the cell when used in the left side of the relation. Where: Param—name of a parameter, Value—value to check for, column (optional)—column number." },
    "value_by_argument": { "prefix": "value_by_argument", "body": [ "value_by_argument(${1:Param},${2:Argument},${3:interpolation_order})" ], "description": "Returns the value in the same row as the argument found when it exists, or a linear interpolation between the two closest values. When argument is out of the interval, the result is undefined and an error is shown. Param—name of a parameter, Argument—value in the first (left) column, interpolation_order—specifies an exact match (0), or linear interpolation (1)." },
    "weighted_average": { "prefix": "weighted_average", "body": [ "weighted_average(${1:Param})" ], "description": "Returns the weighted average value of thecColumn values of the parameter. The weighted average is calculated by the formula: Sum (Ti+1-TI*(vi+1+VI/2))/(Tlast-T0). When argument values change with a constant step, the value returned is the simple arithmetic mean of all values. Where: Param—name of a parameter." },
    "rel_model_name": { "prefix": "rel_model_name", "body": [ "rel_model_name()" ], "description": "Returns the current model name." },
    "rel_model_type": { "prefix": "rel_model_type", "body": [ "rel_model_type()" ], "description": "Returns the current model type." },
}

